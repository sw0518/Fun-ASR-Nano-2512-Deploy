<!--
FunASR-Nano-2512 ASR Web Client
作者：凌封
来源：https://aibook.ren (AI全书)
-->
<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xiaozhi ASR Web Client</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            text-align: center;
        }

        .config-panel {
            background: #eef2f7;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .input-group {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }

        .input-group label {
            width: 100px;
            font-weight: bold;
        }

        .input-group input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .controls {
            text-align: center;
            margin: 20px 0;
        }

        button {
            padding: 10px 25px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            transition: background 0.3s;
            margin: 0 10px;
        }

        .btn-start {
            background-color: #28a745;
            color: white;
        }

        .btn-start:hover {
            background-color: #218838;
        }

        .btn-start:disabled {
            background-color: #94d3a2;
            cursor: not-allowed;
        }

        .btn-stop {
            background-color: #dc3545;
            color: white;
        }

        .btn-stop:hover {
            background-color: #c82333;
        }

        .btn-stop:disabled {
            background-color: #e4b5b9;
            cursor: not-allowed;
        }

        .status-bar {
            text-align: center;
            margin-bottom: 15px;
            font-weight: bold;
            color: #666;
        }

        .status-connected {
            color: #28a745;
        }

        .status-disconnected {
            color: #dc3545;
        }

        .result-box {
            border: 1px solid #ddd;
            padding: 20px;
            height: 300px;
            overflow-y: auto;
            background: #fafafa;
            border-radius: 5px;
            line-height: 1.6;
        }

        .text-final {
            color: #000;
        }

        .text-streaming {
            color: #999;
        }

        .log-panel {
            margin-top: 20px;
            font-size: 12px;
            color: #888;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }
    </style>
</head>

<body>

    <div class="container">
        <h1>Fun-ASR-Nano-2512 实时测试</h1>

        <div class="config-panel">
            <div class="input-group">
                <label>WebSocket URL:</label>
                <input type="text" id="ws_url" value="ws://部署ASR的服务器IP:10095" placeholder="ws://ip:port">
            </div>
            <div class="input-group">
                <label>Mode:</label>
                <select id="mode_select" style="flex:1; padding:8px;">
                    <option value="2pass">2pass (流式+修正)</option>
                    <option value="online">online (纯流式)</option>
                </select>
            </div>
        </div>

        <div class="status-bar" id="status_div">状态: 未连接</div>

        <div class="controls">
            <button id="btn_start" class="btn-start" onclick="startRecording()">开始录音</button>
            <button id="btn_stop" class="btn-stop" onclick="stopRecording()" disabled>停止录音</button>
        </div>

        <div class="result-box" id="result_div">
            <div style="color:#ccc; text-align:center; margin-top:100px;">点击“开始录音”说话...</div>
        </div>

        <div class="log-panel" id="log_div"></div>
    </div>

    <script>
        let ws = null;
        let audioContext = null;
        let scriptProcessor = null;
        let audioInput = null;
        let inputStream = null;
        let isRecording = false;

        // Resampling Config
        const TARGET_SAMPLE_RATE = 16000;

        // UI Elements
        const btnStart = document.getElementById('btn_start');
        const btnStop = document.getElementById('btn_stop');
        const resultDiv = document.getElementById('result_div');
        const statusDiv = document.getElementById('status_div');
        const wsUrlInput = document.getElementById('ws_url');
        let finalResults = []; // Store confirmed sentences

        // Auto-detect host
        if (window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
            wsUrlInput.value = `ws://${window.location.hostname}:10095`;
        }

        function log(msg) {
            console.log(msg);
            // document.getElementById('log_div').innerText = msg;
        }

        function updateStatus(msg, type) {
            statusDiv.innerText = "状态: " + msg;
            statusDiv.className = "status-bar " + (type || "");
        }

        function renderResult(streamingText) {
            let html = "";
            // Render finalized sentences
            finalResults.forEach(text => {
                html += `<span class="text-final">${text}</span><br>`;
            });
            // Render current streaming text
            if (streamingText) {
                html += `<span class="text-streaming">${streamingText}</span>`;
            }
            resultDiv.innerHTML = html;
            resultDiv.scrollTop = resultDiv.scrollHeight;
        }

        async function startRecording() {
            try {
                // 1. Initialize WebSocket
                const url = wsUrlInput.value;
                // 重要: 服务端指定了 subprotocols=["binary"]，客户端必须匹配，否则握手失败
                ws = new WebSocket(url, ["binary"]);
                ws.binaryType = "arraybuffer";

                updateStatus("正在连接...", "status-disconnected");

                ws.onopen = () => {
                    log("WebSocket Connected");
                    updateStatus("已连接，正在录音...", "status-connected");

                    // Send Config Frame
                    const mode = document.getElementById('mode_select').value;
                    const config = {
                        "mode": mode,
                        "chunk_size": [5, 10, 5],
                        "chunk_interval": 10,
                        "encoder_chunk_look_back": 4,
                        "decoder_chunk_look_back": 1,
                        "audio_fs": TARGET_SAMPLE_RATE,
                        "wav_name": "web_mic",
                        "is_speaking": true,
                        "itn": true
                    };
                    ws.send(JSON.stringify(config));

                    // Start Audio Capture
                    startAudioCapture();
                };

                ws.onmessage = (event) => {
                    const msg = JSON.parse(event.data);
                    if (msg.text) {
                        if (msg.is_final) {
                            finalResults.push(msg.text); // Commit to final
                            renderResult(""); // Clear streaming
                        } else {
                            renderResult(msg.text); // Update streaming
                        }
                    }
                };

                ws.onerror = (e) => {
                    log("WS Error: " + e);
                    updateStatus("WebSocket 错误", "status-disconnected");
                    stopRecording();
                };

                ws.onclose = () => {
                    log("WS Closed");
                    if (isRecording) stopRecording();
                    updateStatus("连接已断开", "status-disconnected");
                };

                btnStart.disabled = true;
                btnStop.disabled = false;
                isRecording = true;
                resultDiv.innerHTML = "";
                finalResults = [];

            } catch (e) {
                alert("Error: " + e.message);
                console.error(e);
            }
        }

        async function startAudioCapture() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                inputStream = stream;

                // Create Audio Context
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioContext = new AudioContext();

                const source = audioContext.createMediaStreamSource(stream);
                // Use a larger buffer for script processor to reduce callback freq
                const bufferSize = 4096;
                scriptProcessor = audioContext.createScriptProcessor(bufferSize, 1, 1);

                source.connect(scriptProcessor);
                scriptProcessor.connect(audioContext.destination);

                log(`Audio Sample Rate: ${audioContext.sampleRate}`);

                // Buffer to hold raw float32 data until we have enough for a chunk
                let audioBuffer = [];
                // Target chunk duration (ms)
                const CHUNK_DURATION_MS = 60;
                // Target samples per chunk (16000Hz * 60ms = 960 samples)
                const SAMPLES_PER_CHUNK = TARGET_SAMPLE_RATE * CHUNK_DURATION_MS / 1000;

                scriptProcessor.onaudioprocess = (e) => {
                    if (!isRecording) return;

                    const inputData = e.inputBuffer.getChannelData(0); // Float32: -1.0 ~ 1.0

                    // 1. Resample to 16000Hz and append to buffer
                    const resampledData = resampleToFloat(inputData, audioContext.sampleRate, TARGET_SAMPLE_RATE);

                    // Store in global buffer
                    for (let i = 0; i < resampledData.length; i++) {
                        audioBuffer.push(resampledData[i]);
                    }

                    // 2. Send in fixed 60ms chunks (960 samples)
                    while (audioBuffer.length >= SAMPLES_PER_CHUNK) {
                        const chunk = audioBuffer.slice(0, SAMPLES_PER_CHUNK);
                        audioBuffer = audioBuffer.slice(SAMPLES_PER_CHUNK);

                        // Convert chunk to Int16
                        const pcmData = floatTo16BitPCM(new Float32Array(chunk));

                        // Send via WebSocket
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(pcmData);
                        }
                    }
                };

            } catch (e) {
                alert("无法获取麦克风权限，请确保使用 localhost 或 https 访问，或参考服务器终端的提示配置 Chrome Flag。\n错误信息: " + e.message);
                stopRecording();
            }
        }

        // Helper: Resample and return Float32Array (no Int16 conversion yet)
        function resampleToFloat(audioData, sampleRate, targetSampleRate) {
            if (sampleRate === targetSampleRate) {
                return audioData;
            }
            const ratio = sampleRate / targetSampleRate;
            const newLength = Math.round(audioData.length / ratio);
            const result = new Float32Array(newLength);
            let offsetResult = 0;
            let offsetSource = 0;
            while (offsetResult < newLength) {
                const nextOffsetSource = Math.round((offsetResult + 1) * ratio);
                let accum = 0;
                let count = 0;
                for (let i = offsetSource; i < nextOffsetSource && i < audioData.length; i++) {
                    accum += audioData[i];
                    count++;
                }
                result[offsetResult] = count > 0 ? accum / count : 0;
                offsetResult++;
                offsetSource = nextOffsetSource;
            }
            return result;
        }

        function stopRecording() {
            if (!isRecording) return;
            isRecording = false;

            // Stop Audio
            if (inputStream) {
                inputStream.getTracks().forEach(track => track.stop());
            }
            if (scriptProcessor) scriptProcessor.disconnect();
            if (audioContext) audioContext.close();

            // Send End Signal
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ "is_speaking": false }));
                // Don't close immediately, wait for final result
                setTimeout(() => {
                    if (ws) ws.close();
                }, 1000);
            }

            btnStart.disabled = false;
            btnStop.disabled = true;
            updateStatus("录音结束", "status-bar");
        }

        function floatTo16BitPCM(input) {
            const output = new Int16Array(input.length);
            for (let i = 0; i < input.length; i++) {
                const s = Math.max(-1, Math.min(1, input[i])); // Clamp
                output[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }
            return output.buffer;
        }
    </script>

</body>

</html>